#Лабораторные работы по ИТиРОД
## ЛР 1. helloWorld
Создать 2 класса, в двух различных пакетах. Скомпилировать в консоли, запустить из-под консоли.
## ЛР 2. containers
Создать класс для представления матрицы. Добавить операцию перемножения матриц. Проверить работоспособность на нулевой, единичной и произвольной квадратной матрице 4x4 (т.е. перемножить нулевую на нулевую, нулевую на единичную... и проверить результаты вручную или с помощью тестов). Данные в матрице в учебных целях хранить в ArrayList и LinkedList(т.е. создать 2 типа матриц или 2 различных реализации матриц). Сравнить производительность для различных списка (ArrayList и LinkedList) при перемножении матриц 100x100. Обосновать вывод.
## ЛР 3. strings-io
1. Написать класс, который считывает произвольный текстовый файл и выводит статистику использования букв (a - 0.03%, b - 0.14% ,...).
2. Для матриц написать сохранение и чтение в текстовый файл, используя Reader и Writer
3. Для матриц написать сериализацию и десериализацию (ObjectInputStream ObjectOutputStream).
## ЛР 4. threads
Написать эмулятор системы массового обслуживания. Имеется банк с P счетами, N кассирам, M клиентами. Клиент может снимать/лодить деньги с любого из P счёта. Снятые деньги либо остаются у него в кармане некоторое время, либо он сразу же переводит их на другои счёт. Использовать многопоточность и средства синхронизации Java. Написать демона-наблюдателя, который следит за тем, что всё в порядке (что на счетах и в кошельках клиентов сумма > 0, что текущая денежная масса постоянна -- нет утечек). Денежная масса создаётся в начальный момент времени и фиксирована (скажем 1 0000 000$).
Должно быть минимум 30 одновременных потоков. Для синхронизации нельзя использовать один общий глобальный объект (это неправильно, когда при реальной сверке сумм все операции в банке останавлиюваются). Кроме того, нужно предусмотреть следующие ситуации:
1. Проблема синхронизации: 
   - Клиент (поток№1) снял со счёта№1 сумму 10$, с целью положить его на счёт№2
   - Клиент (поток№1) остановился
   - Демон  (поток№2) проверил сумму на счёте №1
   - Демон (поток№2) проверил сумму на счёте №2 
   - Клиент (поток№1) проснулся и положил сумму 10$ на счёт№2
     Таким образом получается, что демон недосчитался 10$, в процессе перевода со счёта на счёт. Эту ситуацию нужно обработать
2. Есть две группы счетов: проверенные демоном (A) и непроверенные демоном (B). В процессе параллельной работы потоков клиенты-потоки из группы A могут безопасно переводить деньги со счёт на счёт также в группе A; аналогичная ситуация для группы B; но переводить деньги со счёта из группа A на счёт группы B (и наоборот) нельзя, т.к. возникнет недостача или пресдача денег, когда их будет подсчитывать демон, что недопустимо. Для разрешения этой ситуации возможно следует использовать объект-брокер, который разрешает или запрещает все операции со счетами (чтение и перевод)  и с которым взаимодействуют потоки-клиенты и поток-демон. Сам брокер, в общем случае, не является потоком.

## ЛР 5. jdbc
Создать простейшую таблицу (4 поля), и для неё написать объект (domain object). Для объекта написать высокоуровневые CRUD-операции добавления (INSERT), сохранения (UPDATE), удаления (DELETE), и чтения (SELECT) из таблицы (dao -- data access object).  Т.е.
```Student s = new Student();
s.setName("Petrov");
IStudentDAO sdao = new StudentDAO();
sdao.save(s);
```
## ЛР 6. Junit
написать junit-тесты к л/р 2,3,4, которые автоматически проверяли бы корректность отработки данных классов. Соответсвующие классы, возможно, нужно модифицировать, чтобы они исполнялись как в рабочем окружении (production), так и в тестовом. У всех классов должно быть журналирование Log4j.

## ЛР 7. Ant
Использовать инструмент ant для сборки проектов в лр.6 (готовых .jar-файлов); причём перед сборкой должны автоматически прогоняться junit тесты, для проверки корректности сборки. В сборку (jar-файл), тестовые классы не должны входить. 
## ЛР 8. hello-servlet
Простейший сервлет и html-форма к нему, так чтобы выполнялись предыдущие операции с JDBC с объектом. Вывести список объектов. 

## ЛР 9. jsp-guest book
1. Написание простейшей гостевой книги или выполнение предыдущей лр с помощью jsp и пользовательских тегов (минимум двух), вроде <my:iterator> и <my:renderObject/>. Эти теги нужно реализовать декларативно (/WEB-INF/tags/*.tag)
2. Реализовать других тега (возможно эти же два, только обязательно, чтобы они взаимодействовали), причём они должны быть реализованы программно, т.к. как TagHandler'ы, у которых имеется соответствующая библиотека тего (taglib).

## ЛР 10. jsp-guest book
Написать сохранение/чтение объекта с помощью DOM и SAX. Все объекты хранятся в БД, используются наработки предыдущих лр. Во всех вариантах лр использовать временные файлы запрещено.
1. Написать сервлет, который выдаёт список объектов в форме XML (/output/xml)
2. Написать фильтр, который используя XSLT-преобразование, используя вывод предыдущего сервлета преобразует его в HTML-вид, читаемый для пользователя (/output/html)
3. Написать форму для заргузки  XML-файла со списком объектов и соответствующий сервлет для вставки этих объектов из XML-файла в БД.
